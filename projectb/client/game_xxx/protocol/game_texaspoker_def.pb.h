// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game_texaspoker_def.proto

#ifndef PROTOBUF_game_5ftexaspoker_5fdef_2eproto__INCLUDED
#define PROTOBUF_game_5ftexaspoker_5fdef_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)

namespace game_texaspoker_protocols {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_game_5ftexaspoker_5fdef_2eproto();
void protobuf_AssignDesc_game_5ftexaspoker_5fdef_2eproto();
void protobuf_ShutdownFile_game_5ftexaspoker_5fdef_2eproto();


enum e_server_msg_type {
  e_mst_start_c2l = 10000,
  e_mst_c2l_get_room_info = 10001,
  e_mst_c2l_join_table = 10002,
  e_mst_c2l_leave_table = 10003,
  e_mst_c2l_get_table_scene_info = 10004,
  e_mst_c2l_req_declare = 10005,
  e_mst_c2l_req_sitdown = 10006,
  e_mst_c2l_show_poker = 10007,
  e_mst_c2l_req_standup = 10008,
  e_mst_c2l_check_state = 10009,
  e_mst_c2l_req_supply = 10010,
  e_mst_c2l_req_chip = 10011,
  e_mst_start_l2c = 15000,
  e_mst_l2c_get_room_info_result = 15001,
  e_mst_l2c_join_table_result = 15002,
  e_mst_l2c_leave_table_result = 15003,
  e_mst_get_table_scene_info_result = 15004,
  e_mst_l2c_game_event_notify = 15005,
  e_mst_l2c_req_declare_result = 15006,
  e_mst_l2c_game_start_notify = 15007,
  e_mst_l2c_req_sitdown_result = 15008,
  e_mst_l2c_game_end_notify = 15009,
  e_mst_l2c_buy_chip_notify = 15010,
  e_mst_l2c_game_wait_notify = 15011,
  e_mst_l2c_show_poker_result = 15012,
  e_mst_l2c_req_standup_result = 15013,
  e_mst_l2c_check_state_result = 15014,
  e_mst_l2c_req_supply_result = 15015,
  e_mst_l2c_req_chip_result = 15016,
  e_mst_clend_index = 20000
};
bool e_server_msg_type_IsValid(int value);
const e_server_msg_type e_server_msg_type_MIN = e_mst_start_c2l;
const e_server_msg_type e_server_msg_type_MAX = e_mst_clend_index;
const int e_server_msg_type_ARRAYSIZE = e_server_msg_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* e_server_msg_type_descriptor();
inline const ::std::string& e_server_msg_type_Name(e_server_msg_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    e_server_msg_type_descriptor(), value);
}
inline bool e_server_msg_type_Parse(
    const ::std::string& name, e_server_msg_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<e_server_msg_type>(
    e_server_msg_type_descriptor(), name, value);
}
enum EDeskPlayerState {
  state_occupy_seat = 0,
  state_in_game = 1,
  state_standup = 2,
  state_reserve = 3
};
bool EDeskPlayerState_IsValid(int value);
const EDeskPlayerState EDeskPlayerState_MIN = state_occupy_seat;
const EDeskPlayerState EDeskPlayerState_MAX = state_reserve;
const int EDeskPlayerState_ARRAYSIZE = EDeskPlayerState_MAX + 1;

const ::google::protobuf::EnumDescriptor* EDeskPlayerState_descriptor();
inline const ::std::string& EDeskPlayerState_Name(EDeskPlayerState value) {
  return ::google::protobuf::internal::NameOfEnum(
    EDeskPlayerState_descriptor(), value);
}
inline bool EDeskPlayerState_Parse(
    const ::std::string& name, EDeskPlayerState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EDeskPlayerState>(
    EDeskPlayerState_descriptor(), name, value);
}
enum EGameEvent {
  event_enter_desk = 0,
  event_leave_desk = 1,
  event_start_declare = 2,
  event_done_declare = 3,
  event_dispatch_common_poker = 4,
  event_stand_up = 5
};
bool EGameEvent_IsValid(int value);
const EGameEvent EGameEvent_MIN = event_enter_desk;
const EGameEvent EGameEvent_MAX = event_stand_up;
const int EGameEvent_ARRAYSIZE = EGameEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* EGameEvent_descriptor();
inline const ::std::string& EGameEvent_Name(EGameEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    EGameEvent_descriptor(), value);
}
inline bool EGameEvent_Parse(
    const ::std::string& name, EGameEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EGameEvent>(
    EGameEvent_descriptor(), name, value);
}
enum EDeskState {
  state_wait_join = 0,
  state_player_seat = 1,
  state_pre_flop = 2,
  state_flop = 3,
  state_turn = 4,
  state_river = 5,
  state_balance = 6
};
bool EDeskState_IsValid(int value);
const EDeskState EDeskState_MIN = state_wait_join;
const EDeskState EDeskState_MAX = state_balance;
const int EDeskState_ARRAYSIZE = EDeskState_MAX + 1;

const ::google::protobuf::EnumDescriptor* EDeskState_descriptor();
inline const ::std::string& EDeskState_Name(EDeskState value) {
  return ::google::protobuf::internal::NameOfEnum(
    EDeskState_descriptor(), value);
}
inline bool EDeskState_Parse(
    const ::std::string& name, EDeskState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EDeskState>(
    EDeskState_descriptor(), name, value);
}
enum EPokerFlower {
  flower_spade = 1,
  flower_hearts = 2,
  flower_club = 3,
  flower_diamond = 4
};
bool EPokerFlower_IsValid(int value);
const EPokerFlower EPokerFlower_MIN = flower_spade;
const EPokerFlower EPokerFlower_MAX = flower_diamond;
const int EPokerFlower_ARRAYSIZE = EPokerFlower_MAX + 1;

const ::google::protobuf::EnumDescriptor* EPokerFlower_descriptor();
inline const ::std::string& EPokerFlower_Name(EPokerFlower value) {
  return ::google::protobuf::internal::NameOfEnum(
    EPokerFlower_descriptor(), value);
}
inline bool EPokerFlower_Parse(
    const ::std::string& name, EPokerFlower* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EPokerFlower>(
    EPokerFlower_descriptor(), name, value);
}
enum EDeclare {
  declare_none = 0,
  declare_abandon = 1,
  declare_call_bet = 2,
  declare_add_bet = 3,
  declare_all_in = 4,
  declare_pass = 5,
  declare_thinking = 6
};
bool EDeclare_IsValid(int value);
const EDeclare EDeclare_MIN = declare_none;
const EDeclare EDeclare_MAX = declare_thinking;
const int EDeclare_ARRAYSIZE = EDeclare_MAX + 1;

const ::google::protobuf::EnumDescriptor* EDeclare_descriptor();
inline const ::std::string& EDeclare_Name(EDeclare value) {
  return ::google::protobuf::internal::NameOfEnum(
    EDeclare_descriptor(), value);
}
inline bool EDeclare_Parse(
    const ::std::string& name, EDeclare* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EDeclare>(
    EDeclare_descriptor(), name, value);
}
enum EPokerType {
  poker_type_royal_flush = 0,
  poker_type_straight_flush = 1,
  poker_type_four_of_a_kind = 2,
  poker_type_full_house = 3,
  poker_type_flush = 4,
  poker_type_straight = 5,
  poker_type_three_of_a_kind = 6,
  poker_type_two_pairs = 7,
  poker_type_one_pairs = 8,
  poker_type_high_card = 9,
  poker_type_max = 10
};
bool EPokerType_IsValid(int value);
const EPokerType EPokerType_MIN = poker_type_royal_flush;
const EPokerType EPokerType_MAX = poker_type_max;
const int EPokerType_ARRAYSIZE = EPokerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EPokerType_descriptor();
inline const ::std::string& EPokerType_Name(EPokerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EPokerType_descriptor(), value);
}
inline bool EPokerType_Parse(
    const ::std::string& name, EPokerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EPokerType>(
    EPokerType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================


// @@protoc_insertion_point(namespace_scope)

}  // namespace game_texaspoker_protocols

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game_texaspoker_protocols::e_server_msg_type>() {
  return ::game_texaspoker_protocols::e_server_msg_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game_texaspoker_protocols::EDeskPlayerState>() {
  return ::game_texaspoker_protocols::EDeskPlayerState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game_texaspoker_protocols::EGameEvent>() {
  return ::game_texaspoker_protocols::EGameEvent_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game_texaspoker_protocols::EDeskState>() {
  return ::game_texaspoker_protocols::EDeskState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game_texaspoker_protocols::EPokerFlower>() {
  return ::game_texaspoker_protocols::EPokerFlower_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game_texaspoker_protocols::EDeclare>() {
  return ::game_texaspoker_protocols::EDeclare_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game_texaspoker_protocols::EPokerType>() {
  return ::game_texaspoker_protocols::EPokerType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_game_5ftexaspoker_5fdef_2eproto__INCLUDED
